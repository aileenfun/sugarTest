/*
 * Copyright (c) 2006-2020, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes
 * 2020-07-30     alanliu       the first version
 */
#include "UartInput.h"
#include <rtthread.h>
#include <rtdevice.h>
#include <string.h>
#define MSGBUFFLEN 600
#define RD_BUFF_SIZE 1024
char dark_buff[514];
char light_buff[514];
int buffIdx=0;
float input0[256]={34.33333333,72.66666667,55,55.33333333,88.33333333,47,33,91.33333333,64,-16.66666667,34.66666667,29,-3.666666667,25.33333333,65.66666667,19,6.666666667,-5.333333333,3,-13.66666667,4,9.666666667,17.33333333,16,36.66666667,-5.666666667,-11,0.666666667,20.33333333,60.66666667,-15.66666667,4.333333333,69.33333333,31,16.66666667,1.666666667,16.66666667,24.33333333,-6,9.333333333,12.33333333,-6.333333333,-10.66666667,-19.33333333,18.66666667,-2,13.33333333,8,-17.33333333,12.66666667,21.33333333,24.66666667,-3.666666667,-11.33333333,4.666666667,-4.666666667,41,-0.666666667,-19,2.666666667,-33,950.3333333,2858,2378.666667,3214.666667,4517.666667,4571.666667,5443,6446.666667,7750.666667,8952.666667,10187,11486.33333,12441.66667,13566,14538,15545.66667,16616.33333,18044.33333,19054.33333,20566.33333,22093,23575.33333,25226,26974.66667,28949,30554,32675.33333,34646.66667,35784,36823.66667,37499.33333,39070.33333,40210.33333,42442,44406.33333,47622.66667,49239.66667,50786.33333,51871,52535.33333,53420.33333,54131.66667,54941,55619.66667,56151.66667,56360.33333,56648.66667,56456.66667,56783,56633.33333,57495,57911,57882,57640.33333,57509.66667,57034.33333,57111.33333,56541.66667,56582,57627,57500.66667,57569,57718,57519.66667,58008.66667,57301,57595.33333,58101.66667,58500,57780.66667,57430.33333,56905.66667,56628.66667,56456.66667,56190,56173,56275,55890.33333,55558,55348.66667,54645,54184.66667,53694.33333,53754.66667,53214.33333,52659,51883,50804.66667,50045.66667,48861,48010.33333,47257,45986.66667,44209,42705.33333,40880,39304.66667,37449,35804.66667,35085,33277.33333,31935,30499.33333,29070.33333,27707,26226.66667,25003.66667,23811.33333,22982.33333,21735,20450,19231.66667,18059.66667,17023.33333,15922.33333,15098.66667,13983,13114,12270.66667,11434.33333,10577,9823,9042.333333,8756,8113.333333,7415,6922.333333,6375.666667,6051.333333,5489.666667,5102.666667,4808.333333,4732,4263,4070,3753.666667,3556,3451.666667,3569,3485.333333,3389,3115.333333,3019,2904,2935.333333,2990,2783.666667,2836.333333,2815,2862.666667,2671.333333,2915.666667,2681,2695,2369,2566.333333,2552,2553.333333,2485.333333,2535,2370.666667,2421.666667,2273.666667,2514.333333,2327.333333,2624,2394,2375.666667,2297,2163.333333,1963.333333,2086.333333,1786.666667,1591,1912,1850,1606.333333,1754.333333,1667,1996.666667,1952.333333,1626.666667,1965.666667,1980.333333,1659.666667,1627.333333,1345,1904.666667,1763.666667,1628.333333,2048.333333,1724,1708.333333,1901.666667,1529};
    float input1[256]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.045747728,-0.043831116,-0.026697643,0.038306383,0.044442787,0.033032685,0.040696175,0.016580709,0.019542894,-0.001656445,-0.020945813,-0.042173521,-0.034100696,-0.03539903,-0.015102511,0.011105301,0.057890633,0.090188524,0.102900519,0.087116443,0.056603615,0.051632697,0.008646275,0.000856905,-0.027852351,-0.015958243,-0.053239801,-0.044859643,-0.053571819,-0.049212715,-0.035591623,-0.029307029,-0.021490604,-0.016077765,-0.007188881,-0.005144568,-0.007098101,-0.002157936,0.001313736,-0.004845848,0.011454112,-6.11E-05,0.016105295,0.000347922,-0.000357459,0.002661237,0.003354283,-0.001004051,-0.006639152,-0.001323588,-0.01650759,-0.014388654,-0.024267997,-0.029502879,-0.033534982,-0.026577078,-0.025296073,-0.019092655,-0.007287442,-0.01453636,-0.012096422,-0.014135956,-0.00522811,-0.016189049,-0.005778175,-0.010042099,-0.010841118,-0.014356169,-0.007394186,-0.019202352,-0.007353403,-0.020048371,-0.01109982,-0.012033598,-0.005485604,-0.017412909,-0.007966791,-0.011566589,-0.01539475,-0.012911132,-0.009879662,-0.018717336,-0.013515306,-0.022982862,-0.021004436,-0.020151782,-0.019773469,-0.024441829,-0.017103942,-0.024189837,-0.00896964,-0.009275521,0.004724985,-0.01227887,0.01966212,-0.007877861,-0.009577738,-0.017232514,0.02062996,4.76E-18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    float input2[256]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.228920774,1.5056167,1.658057754,4.685336639,5.201899878,13.50390817,3.179502381,12.19370868,1.87221845,-0.026621075,-2.113353014,-14.01203572,-8.60223151,-1.876095524,6.717193456,-9.896914982,-7.221743744,-10.54817012,-3.174820274,4.461228805,-9.064883001,1.021871492,0.669334232,0.807082222,9.781834552,1.577059642,9.204560309,10.1111707,9.429169888,8.944588999,-9.795966422,2.203715405,-4.513262372,-2.211483837,-4.466183725,-5.451400816,2.090765916,-3.480707123,1.617458605,-3.296958659,7.103224769,-8.02E+00,-9.624337946,4.156274673,1.547776203,-1.347096124,-5.742297339,0.861537196,-3.012201997,1.832734201,3.880575708,3.132632252,9.222805959,12.32340293,9.772762854,13.22360865,0.802749004,9.836483477,-3.634149276,5.111326871,4.261170769,-0.763052823,5.566419997,-1.469009321,-0.043309166,-0.802380506,-1.356321906,6.724585476,-3.812650116,0.090496492,-1.728459941,-0.197693321,0.420053442,-4.791858823,-4.719794562,-1.677611371,1.598734833,-3.13886593,2.518184499,3.117514463,-0.795701351,9.756329623,-0.937009398,7.052497181,8.479180722,11.70772686,2.055752176,15.43269006,-2.476711696,16.5324162,0.884738145,10.82907806,-1.394912135,-1.980254896,5.816311086,-4.924802942,-2.938922394,-4.965385343,-11.83778482,1.67E-13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    float input3=13.928606741573030;
    float difffloat[257]={0};
    float difffloat2[257]={0};
//  https://club.rt-thread.org/ask/question/11097.html
/* 串口接收消息结构*/
struct rx_msg
{
    rt_device_t dev;
    rt_size_t size;
    char buff[MSGBUFFLEN];
};
/* 串口设备句柄 */
static rt_device_t Fpga2ArmSerial;
static rt_device_t txSerial;
/* 消息队列控制块 */
static struct rt_messagequeue rx_mq;
static struct rt_semaphore rx_sem;
/* 接收数据回调函数 */
int counter = 1;
int f_light=3;
float CalcBuff(int sugmode)
{

    //float diffint[257]={0};
    //const float lightTestData[]={1597,1403,1509,1402,1478,1525,1597,1416,1490,1620,1591,1482,1712,1561,1524,1681,1725,1750,1758,1717,1801,1708,1743,1665,1554,1581,1731,1670,1724,1488,1660,1660,1512,1610,1651,1630,1693,1636,1708,1682,1767,1644,1732,1682,1714,1686,1569,1679,1717,1710,1688,1649,1665,1667,1710,1666,1660,1588,1698,1704,1725,3156,3101,3225,3342,3323,3349,2948,2963,4059,4830,6065,5586,6280,6267,6430,6533,6441,6307,6169,6272,6048,5966,6099,6907,8608,11633,15737,20153,23854,26713,28509,30309,30836,31948,32082,33220,32786,32833,32735,32448,32575,33021,32904,33570,34031,34479,34295,34508,34679,34637,35510,35824,36051,35993,35699,35129,35018,34163,33490,33270,31910,30331,29304,28258,27388,26706,25998,25848,25488,24427,23925,23228,22801,21857,21142,20964,20341,19141,18723,17979,17123,16360,15837,15342,14676,14096,13211,12321,11623,10561,9696,8861,8052,7136,6517,6239,5949,5699,5113,4721,2977,2728,2989,2881,2674,2603,2496,2604,2595,3188,3374,3511,3354,3462,3433,3394,3281,3449,3412,3520,3363,3565,3367,3474,3216,3301,3041,3209,3193,3250,2974,3320,3055,2991,2893,3142,3020,3163,2840,2604,2671,3089,3004,3103,2796,2866,2857,2890,2723,2784,2918,2793,2787,2676,2601,2786,2704,2742,2766,2753,2826,2722,2684,2794,3217,2962,2813,2797,2846,2793,3000,2972,2688,2962,2937,2869,2831,2860,3169,3146,2840,3289,3028,2963,2869,2807,3758,3101,3039,4372,2869,3124,3169,3128,3282};
    //const float darkTestData[]={1589,1376,1479,1377,1527,1508,1581,1419,1452,1610,1613,1508,1724,1560,1492,1697,1755,1730,1763,1685,1784,1727,1729,1677,1558,1611,1738,1626,1733,1518,1665,1639,1434,1630,1648,1631,1667,1628,1696,1657,1740,1650,1739,1702,1727,1704,1605,1667,1703,1698,1700,1673,1699,1669,1706,1681,1700,1616,1704,1688,1743,1724,1703,1673,1724,1705,1693,1679,1713,1673,1697,1697,1776,1637,1696,1639,1653,1606,1679,1612,1687,1590,1594,1607,1665,1609,1645,1639,1734,1767,1817,1813,1995,1808,1953,1686,2447,2095,1848,1936,1890,1740,1748,1621,1683,1808,2549,1783,1775,1692,1630,2687,2214,2136,2071,1713,1843,2044,2098,2042,1972,1833,1838,2070,1898,1653,1988,1849,1794,2384,1758,1859,1759,2010,1721,1736,1919,2404,1741,2276,1811,1793,1758,1964,1830,1773,2097,2040,1792,1990,1934,1857,1935,1891,1868,1815,2068,2026,2031,2170,2094,2213,1815,2304,2125,2550,2772,2695,3039,2174,2621,2083,2068,2525,2578,2334,2864,3035,2944,2797,2645,2774,2712,3026,3303,2969,3106,3276,3136,2912,3303,3284,2878,3086,3412,3315,3407,3316,3222,2985,3473,2885,3318,3296,3432,3380,3296,3292,3446,3293,3373,3114,3288,3218,3555,3364,3239,3114,3261,3205,3446,3341,3459,3252,3225,2803,2708,2519,2561,2522,2645,2597,2677,2474,2655,2783,2726,2520,2584,3061,2854,2732,2767,3037,2795,2711,2650,3061,2897,3092,3461,2759,2940,2917,2854,3202};

    float accum=0;
    float tempdark=0;
    float templight=0;
    int i=0;
    int j=0;

    for(i=0;i<514;i=i+2)
    {
        templight=light_buff[i+2];
        templight=templight*256+light_buff[i+2+1];
        tempdark=dark_buff[i+2];
        tempdark=tempdark*256+dark_buff[i+2+1];
        difffloat[j]=(templight-tempdark)/(input0[j]);//3.2
        j=j+1;
    }

//    for(i=0;i<256;i++)
//    {
//        difffloat[i]=(lightTestData[i]-darkTestData[i])/(input0[i]);
//    }
   // memcpy(diffint,difffloat,sizeof(difffloat));

    for(j=1;j<257;j++)
    {

        difffloat2[j]=difffloat[j]-difffloat[j-1];//4

        difffloat[j-1]=difffloat2[j-1]-input1[j-1];//5
        accum=difffloat[j-1]*input2[j-1]+accum;//6

    }

    accum=accum+input3;//7
    switch(sugmode)
    {
    case 0:
        break;
    case 1:
        accum=accum+1;
        break;
    case 2:
        accum=accum+2;
        break;
    case 3:
        accum=accum-1;
        break;
    case 4:
        accum=accum-2;
        break;
    }
    return accum;
}
int trig1Frame(int s)
{
    char tempLightbuf[]={0x55,0xaa,0x05,0x01,0x0a,0x4B,0x01,0x00,0x33,0xcc};
    char tempDarkBuff[]={0x55,0xaa,0x05,0x01,0x0a,0x4B,0x00,0x00,0x33,0xcc};

    if(s==0)
    {
        buffIdx=0;
        memset(dark_buff,0,514);
        f_light=0;
        rt_device_write(Fpga2ArmSerial,0,tempDarkBuff,10);
        //rt_device_write(txSerial,0,tempDarkBuff,10);
    }
    if(s==1)
    {
        buffIdx=0;
        memset(light_buff,0,514);
        f_light=1;
        rt_device_write(Fpga2ArmSerial,0,tempLightbuf,10);
        //rt_device_write(txSerial,0,tempLightbuf,10);

    }

}
int send2PC(int s)
{
    if(s==0)
    {
        //rt_device_write(txSerial,0,dark_buff,sizeof(dark_buff));
    }
    if(s==1)
    {
        //rt_device_write(txSerial,0,light_buff,sizeof(light_buff));
    }
}
static rt_err_t uart_input(rt_device_t dev, rt_size_t size)
{
#ifdef USE_DMA
    struct rx_msg msg;
    int length = 0;
    rt_err_t result;
    msg.dev = dev;
    msg.size = size;
//    if(size!=counter)
//    {
//        rt_kprintf("---------------------------------------\n");
//        rt_kprintf("send error size= %d != %d",size,counter);
//        counter=size;
//    }
//    rt_kprintf("\n");
//    rt_kprintf("send msg addr:%x\n", &msg);
    if (size > MSGBUFFLEN)
    {
        //rt_kprintf("\n");
       // rt_kprintf("error:::: size=%d\n", size);
        size = MSGBUFFLEN;
    }

    rt_device_read(dev, 0, msg.buff, size);
//    memset(msg.buff, counter, MSGBUFFLEN);
//    counter++;
    result = rt_mq_send(&rx_mq, &msg, sizeof(msg));

    if (result == -RT_EFULL)
    {
        rt_kprintf("message queue full！\n");
    }

    return result;
#else
    return 0;
#endif

}
int debounce=0;
static void serial_thread_entry(void *parameter)
{

    rt_base_t level;
    //struct rx_msg msg;
    rt_err_t result;
    rt_uint32_t rx_length;
    static char rx_buffer[RD_BUFF_SIZE];

    while (1)
    {
#ifdef USE_DMA
        rt_memset(&msg, 0, sizeof(msg));
                // 从消息队列中读取消息
                result = rt_mq_recv(&rx_mq, &msg, sizeof(msg), RT_WAITING_FOREVER);
                if (result == RT_EOK)
                {
            //        rt_kprintf("\n");
             //       rt_kprintf("recv addr:%x\n", &msg);
              //      rt_kprintf("\n");
                    level = rt_hw_interrupt_disable();
                    for (int i = 0; i < msg.size; i++)
                    {
                       // msg.buff[i]=0;
                        rt_kprintf("%c", msg.buff[i]);
                    }
                    rt_hw_interrupt_enable(level);
//                    rt_kprintf("recv size:%d\n",msg.size);
//                    if(msg.size!=counter)
//                    {
//                        rt_kprintf("---------------------------------------\n");
//                        rt_kprintf("recv error size: %d !=%d",msg.size,counter);
//                        counter=msg.size;
//                    }
                }
                else
                {
                    rt_thread_mdelay(100);
                }


#else
        rx_length = rt_device_read(Fpga2ArmSerial, 0, rx_buffer, RD_BUFF_SIZE);
        if(rx_length>0)
        {
            //rt_kprintf("rx_length:%d\n",rx_length);
            //level = rt_hw_interrupt_disable();

            if(f_light==0)
            {
                memcpy(dark_buff+buffIdx,rx_buffer,rx_length);
                buffIdx+=rx_length;
            }
            else {
                memcpy(light_buff+buffIdx,rx_buffer,rx_length);
                buffIdx+=rx_length;
            }
            //rt_device_write(txSerial,0,rx_buffer,rx_length);
//            for(int i=0;i<rx_length;i++)
//            {
//                rt_kprintf("%c",rx_buffer[i]);
//            }
            //rt_hw_interrupt_enable(level);
           // rt_kprintf("\n");
        }
        else
        {
            rt_thread_mdelay(10);
        }
        /*
        rx_length=0;
        rx_length=rt_device_read(txSerial,0,rx_buffer,10);
        if(rx_length>0)
        {
            rt_device_write(Fpga2ArmSerial,0,rx_buffer,rx_length);
        }
        else
        {
            rt_thread_mdelay(1);
        }*/

#endif
    }
}

int uart_dma_sample()
{
    rt_err_t ret = RT_EOK;
    char uart_name[RT_NAME_MAX];
    static char msg_pool[4096];
    char str[] = "hello RT-Thread!\r\n";

    /* 查找串口设备 */
    Fpga2ArmSerial = rt_device_find("uart1");
    txSerial=rt_device_find("uart2");
    if (!Fpga2ArmSerial)
    {
        rt_kprintf("find %s failed!\n", uart_name);
        return RT_ERROR;
    }
    if (!txSerial)
        {
            rt_kprintf("find uart1 failed!\n");
            return RT_ERROR;
        }

    rt_sem_init(&rx_sem, "rx_sem", 0, RT_IPC_FLAG_FIFO);
    /* 初始化消息队列 */
    rt_mq_init(&rx_mq, "rx_mq", msg_pool, /* 存放消息的缓冲区 */
    sizeof(struct rx_msg), /* 一条消息的最大长度 */
    sizeof(msg_pool), /* 存放消息的缓冲区大小 */
    RT_IPC_FLAG_FIFO); /* 如果有多个线程等待，按照先来先得到的方法分配消息 */

    /* 以 DMA 接收及轮询发送方式打开串口设备 */
    struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT; /* 初始化配置参数 */
    /* step2：修改串口配置参数 */
    config.baud_rate = BAUD_RATE_115200;
    config.data_bits = DATA_BITS_8;           //数据位 8
    config.stop_bits = STOP_BITS_1;           //停止位 1
    config.bufsz = RT_SERIAL_RB_BUFSZ;                  //修改缓冲区 buff size 为 64
    config.parity = PARITY_NONE;           //无奇偶校验位
    ret = rt_device_control(Fpga2ArmSerial, RT_DEVICE_CTRL_CONFIG, &config);
    rt_device_control(txSerial,RT_DEVICE_CTRL_CONFIG,&config);
    ret=rt_device_open(Fpga2ArmSerial, RT_DEVICE_FLAG_INT_RX);           //RT_DEVICE_FLAG_INT_RX RT_DEVICE_FLAG_DMA_RX
    if(ret!=RT_EOK)
    {
        rt_kprintf("open uart1 failed!\n");
                   return RT_ERROR;
    }
    ret=rt_device_open(txSerial, RT_DEVICE_FLAG_INT_TX);
    if(ret!=RT_EOK)
        {
    rt_kprintf("find uart2 failed!\n");
               return RT_ERROR;
        }
    /* 设置接收回调函数 */
    rt_device_set_rx_indicate(Fpga2ArmSerial, uart_input);


    /* 创建 serial 线程 */
    rt_thread_t thread = rt_thread_create("serial", serial_thread_entry, RT_NULL, 2048, 9, 10);
    /* 创建成功则启动线程 */
    if (thread != RT_NULL)
    {
        rt_thread_startup(thread);
    }
    else
    {
        ret = RT_ERROR;
    }

    return ret;
}
/* 导出到 msh 命令列表中 */
MSH_CMD_EXPORT(uart_dma_sample, uart device dma sample);
